<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NGUI渲染框架]]></title>
    <url>%2F2019%2F03%2F27%2FNGUI%E6%B8%B2%E6%9F%93%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[本文基于NGUI3.9.6，目前我们游戏用的NGUI版本。主要介绍一下NGUI渲染框架，基于本人阅读NGUI源码及其相关资料得出，如有误欢迎指正。 1、渲染基础组件 UIGeometry是用于保存UIWidget需要用的几何数据，里面主要有verts、uvs、cols UIWidget是NGUI基础组件（UILabel、UITexture和UISprite）的基类。主要包含了组件的一些基本信息（宽高、锚点和深度等）。 UIDrawCall 用于负责绘制的类，负责把UIWidget和UIGeometry里面的数据绘制出来 UIPanel 用来管理多个UIWidget、UIDrawcall的渲染、裁剪和更新等。 2、各个组件之间的关系 点击此处可查看大图 3、渲染流程这里先借用网上一张渲染流程图。借用地址链接：https://www.cnblogs.com/Persona/p/4149086.html UIGeometryUIGeometry内提供了verts（顶点）、uvs（UV坐标）、cols（颜色）和相对于panel的mRtpVerts（顶点）、mRtpNormal（法线）、mRtpTan（切线）的数据变量。对外提供了三个方法Clear(清理数据)、ApplyTransform、WriteToBuffers（写缓存）。主要方法：123456789101112131415161718 //用来计算把widget数据通过矩阵转化到panel数据public void ApplyTransform (Matrix4x4 widgetToPanel, bool generateNormals = true)&#123; if (verts.size &gt; 0) &#123; mRtpVerts.Clear(); for (int i = 0, imax = verts.size; i &lt; imax; ++i) mRtpVerts.Add(widgetToPanel.MultiplyPoint3x4(verts[i])); // Calculate the widget&apos;s normal and tangent if (generateNormals) &#123; mRtpNormal = widgetToPanel.MultiplyVector(Vector3.back).normalized; Vector3 tangent = widgetToPanel.MultiplyVector(Vector3.right).normalized; mRtpTan = new Vector4(tangent.x, tangent.y, tangent.z, -1f); &#125; &#125; else mRtpVerts.Clear();&#125; UIWidgetUIWidget作为NGUI基础组件提供一些基本属性操作。这里主要还是讨论他和UIGeometry和UIPanel之间的关系。 UIWidget中定了两个变量。Panel用来管理widget，geometry是widget的数据。12345678/// &lt;summary&gt;/// Panel that&apos;s managing this widget./// &lt;/summary&gt;[System.NonSerialized] public UIPanel panel;/// &lt;summary&gt;/// Widget&apos;s generated geometry./// &lt;/summary&gt;[System.NonSerialized] public UIGeometry geometry = new UIGeometry(); geometry相当于widget在整个渲染过程中的数据容器。实例化geometry的时候，通过UpdateGeometry方法来填充计算Geometry里面的数据。通过调用OnFill虚方法，最后在UILabel、UITexture、UISprite里面来填充具体对应的数据。12345678910111213141516171819public bool UpdateGeometry (int frame) &#123; //省略部分代码 if (mChanged) &#123; mChanged = false; if (mIsVisibleByAlpha &amp;&amp; finalAlpha &gt; 0.001f &amp;&amp; shader != null) &#123; bool hadVertices = geometry.hasVertices; if (fillGeometry) &#123; geometry.Clear(); OnFill(geometry.verts, geometry.uvs, geometry.cols); &#125; //省略部分代码 &#125; //省略部分代码 &#125; //省略部分代码 panel和widget的关系是一个引用的关系。widget保留了对其管理的panel的引用。是start的时候会去创建panel的引用。123456789101112131415161718/// &lt;summary&gt;/// Ensure we have a panel referencing this widget./// &lt;/summary&gt;public UIPanel CreatePanel ()&#123; if (mStarted &amp;&amp; panel == null &amp;&amp; enabled &amp;&amp; NGUITools.GetActive(gameObject)) &#123; panel = UIPanel.Find(cachedTransform, true, cachedGameObject.layer); if (panel != null) &#123; mParentFound = false; panel.AddWidget(this); CheckLayer(); Invalidate(true); &#125; &#125; return panel;&#125; UIDrawCallUIDrawCall和UIWidget的关系相当于有一堆UIWidget的数据需要被绘制，通过UIDrawCall组装起来生成Material用来渲染。UIDrawCall的Material的创建和更新在UpdateGeometry中。这个方法只有在UIPanel的FillAllDrawCalls和FillDrawCall中调用。每个Drawcall对应一个mesh，如果该DrawCall里面的包含的UIWidget有变动。那么就会调用UpdateGeometry更新数据才能重新更新效果。所以在开发过程中，应该避免UIWidget的变动，比如SetActive等。 UIDrawCall重要函数UpdateGeometry12345678910111213141516171819202122232425262728293031323334/// Set the draw call&apos;s geometry.public void UpdateGeometry (int widgetCount)&#123; //省略部分代码 if (verts.size &lt; 65000) &#123; //省略部分代码 // Create the mesh 创建mesh if (mMesh == null) &#123; mMesh = new Mesh(); mMesh.hideFlags = HideFlags.DontSave; mMesh.name = (mMaterial != null) ? &quot;[NGUI] &quot; + mMaterial.name : &quot;[NGUI] Mesh&quot;; mMesh.MarkDynamic(); setIndices = true; &#125; //省略部分代码 //填充绘制需要的数据 mMesh.vertices = verts.buffer; mMesh.uv = uvs.buffer; mMesh.colors32 = cols.buffer; if (norms != null) mMesh.normals = norms.buffer; if (tans != null) mMesh.tangents = tans.buffer; if (setIndices) &#123; mIndices = GenerateCachedIndexBuffer(count, indexCount); mMesh.triangles = mIndices; &#125; //省略部分代码 //更新材质 UpdateMaterials(); &#125;&#125; UIPanelUIPanel在NGUI中充当了一个管理者的角色。管理这UIDrawCall和UIWidget的渲染、裁剪和更新时机。UIPanel中主要的函数LateUpdate、FillAllDrawCalls和FillDrawCall。在Unity的Profile中经常能看到UIPanel.LateUpdate这个函数的CPU和GC都是占用很高的。 LateUpdateLateUpdate中更新了所有panel和drawcall。在LateUpdate中会遍历所有Panel,调用Panel中的UpdateDrawcall方法。更新所有DrawCall。LateUpdate中确保了每帧执行一次。12345678910111213141516171819202122232425262728293031323334353637383940void LateUpdate () &#123; //这里确保每帧执行一次，这个对CPU和GPU消耗很大，需要控制执行次数 if (mUpdateFrame != Time.frameCount) &#123; mUpdateFrame = Time.frameCount; // Update each panel in order for (int i = 0, imax = list.Count; i &lt; imax; ++i) list[i].UpdateSelf(); int rq = 3000; // Update all draw calls, making them draw in the right order for (int i = 0, imax = list.Count; i &lt; imax; ++i) &#123; UIPanel p = list[i]; if (p.renderQueue == RenderQueue.Automatic) &#123; p.startingRenderQueue = rq; p.UpdateDrawCalls(); //这里默认在Panel的RenderQueue之间拉开3个差值 rq += p.drawCalls.Count * 3; &#125; else if (p.renderQueue == RenderQueue.StartAt) &#123; p.UpdateDrawCalls(); if (p.drawCalls.Count != 0) rq = Mathf.Max(rq, p.startingRenderQueue + p.drawCalls.Count); &#125; else // Explicit &#123; p.UpdateDrawCalls(); if (p.drawCalls.Count != 0) rq = Mathf.Max(rq, p.startingRenderQueue + 1); &#125; &#125; &#125; &#125; 在阅读LateUpdate主要关注调用的UpdateSelf和UpdateDrawCalls方法。在UpdateSelf中主要更新了Transform、Layer、Widgets和根据需求重建Drawcall。UpdateDrawCalls更新裁剪区域和drawcall层级等信息。 FillAllDrawCalls和FillDrawCallFillAllDrawCalls是处理所有Widget和重建所有drawcall。FillDrawCalls针对某一个特殊的Drawcall更新Geometry。这里主要介绍FillAllDrawCalls。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/// &lt;summary&gt; /// Fill the geometry fully, processing all widgets and re-creating all draw calls. /// &lt;/summary&gt; void FillAllDrawCalls () &#123; //清理所有Drawcall for (int i = 0; i &lt; drawCalls.Count; ++i) UIDrawCall.Destroy(drawCalls[i]); drawCalls.Clear(); //省略部分代码 //重建Widget if (mSortWidgets) SortWidgets(); for (int i = 0; i &lt; widgets.Count; ++i) &#123; UIWidget w = widgets[i]; if (w.isVisible &amp;&amp; w.hasVertices) &#123; Material mt = w.material; Texture tx = w.mainTexture; Shader sd = w.shader; //如果当前用的材质、纹理和shader和上一个widget的不同的话增加一个Drawcall if (mat != mt || tex != tx || sdr != sd) &#123; if (dc != null &amp;&amp; dc.verts.size != 0) &#123; drawCalls.Add(dc); dc.UpdateGeometry(count); dc.onRender = mOnRender; mOnRender = null; count = 0; dc = null; &#125; mat = mt; tex = tx; sdr = sd; &#125; //drawcall为空的话，新建一个drawcall if (mat != null || sdr != null || tex != null) &#123; if (dc == null) &#123; dc = UIDrawCall.Create(this, mat, tex, sdr); dc.depthStart = w.depth; dc.depthEnd = dc.depthStart; dc.panel = this; &#125; else &#123; int rd = w.depth; if (rd &lt; dc.depthStart) dc.depthStart = rd; if (rd &gt; dc.depthEnd) dc.depthEnd = rd; &#125; w.drawCall = dc; // 写入缓存 ++count; if (generateNormals) w.WriteToBuffers(dc.verts, dc.uvs, dc.cols, dc.norms, dc.tans); else w.WriteToBuffers(dc.verts, dc.uvs, dc.cols, null, null); if (w.mOnRender != null) &#123; if (mOnRender == null) mOnRender = w.mOnRender; else mOnRender += w.mOnRender; &#125; &#125; &#125; else w.drawCall = null; &#125; if (dc != null &amp;&amp; dc.verts.size != 0) &#123; drawCalls.Add(dc); dc.UpdateGeometry(count); dc.onRender = mOnRender; mOnRender = null; &#125; &#125; FillAllDrawCalls中住的流程如下： graph TD A[清理所有DrawCall...] --> B[对Widget重新排序...] B --> C[重新更新Geomtry...] C --> D[写缓存...] 上图可以看到，在重建DrawCall的时候会重新对Widget排序，还会重新更新计算Geometry。所以这个调用是很耗时的。而FillAllDrawCalls在UIPanel中的UpdateSelf里面当mRebuild为true的时候才会重建所有Drawcall。而mRebuild的在UIPanel中在OnInit、OnEnable、RemoveWidget、Refresh中会调用。所以在我们制作UI界面的时候应该尽量避免触发这几个函数以免对Drawcall重建。造成大的消耗。 所以通过对上面的分析可以看得出，影响Drawcall的因素主要有下面几个。在实际开发中可以规划好widget，针对下面的因素来优化drawcall。 不同panel中的Widget无法合并drawcall 同一个panel中会根据panel下的widget中的depth排序，连续的widget使用的相同材质相同纹理以及shader的widget可以合并drawcall widget的add、remove和refresh都会影响drawcall重建。]]></content>
      <categories>
        <category>NGUI</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Charles 代理跳转]]></title>
    <url>%2F2019%2F03%2F21%2FIOSCharles%E4%BB%A3%E7%90%86%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[代理目的通过代理跳转，把游戏的版本文件跳转到测试的目录下，连接test测试相关游戏功能。 步骤1、安装Charles （自行安装，不做介绍，window，mac都可以）2、确保手机和Charles 在同一个局域网3、查看Charles安装机器ip。比如为192.168.0.1384、设置手机wifi代理。代理地址192.168.0.138 端口号：88885、选择Map Remote 6、添加跳转。即可。]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next添加Valine评论系统]]></title>
    <url>%2F2019%2F03%2F21%2FNext%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[介绍Valine - 一款快速、简洁且高效的无后端评论系统。(摘自Valine)1、注册Leancloud评论系统基于Leancloud（Leancloud官网，点我注册） 注册完成之后创建一个应用，名字任意。进入应用-设置应用key 2、打开next的_config.yml12345678910valine: enable: true app_id: app_key: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ヾﾉ≧∀≦)o 来呀！快活呀！~ avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 注意：不同版本字段有所不同。可以在配置文件里面搜valine。 参考Valine官方文档]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unity3D动态替换Lightmap]]></title>
    <url>%2F2019%2F03%2F20%2FUnity3D%E5%8A%A8%E6%80%81%E6%9B%BF%E6%8D%A2Lightmap%2F</url>
    <content type="text"><![CDATA[写在前面最近项目上有个需求，在场景里面需要做一个动态替换lightmap。主要需求是针对场景实现白天和夜晚的灯光效果。 在场景没有变化的时候，我们可以直接替换场景的lightmap即可。 1234567891011public void SetLightMap(Texture2D lightmapTex)&#123; if (lightmapTex == null) &#123; return; &#125; LightmapData[] lightmapData = LightmapSettings.lightmaps; LightmapData lmd = new LightmapData(); lmd.lightmapFar = lightmapTex; lightmapData[0] = lmd; LightmapSettings.lightmaps = lightmapData;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hello world!]]></title>
    <url>%2F2019%2F03%2F19%2Fhello%20world%2F</url>
    <content type="text"><![CDATA[程序员的第一个hello world！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
</search>

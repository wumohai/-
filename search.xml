<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[集成XLua给C#打补丁]]></title>
    <url>%2F2019%2F05%2F02%2F%E9%9B%86%E6%88%90XLua%E7%83%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[最近项目内测出现了许多问题，但是由于项目纯C#开发。导致客户端这边的bug需要重新出包才能解决，看着bug在那毫无办法。项目已经到了中后期使用Lua重写游戏几乎不可能，而且工程量巨大。看了XLua相关介绍，觉得是一个不错的解决方案。所以基于这个问题引入了XLua来临时解决部分线上bug。 XLua简介此次引用XLua官方说明。XLua (Github地址) C#下Lua编程支持xLua为Unity、 .Net、 Mono等C#环境增加Lua脚本编程的能力，借助xLua，这些Lua代码可以方便的和C#相互调用。 xLua的突破xLua在功能、性能、易用性都有不少突破，这几方面分别最具代表性的是： 可以运行时把C#实现（方法，操作符，属性，事件等等）替换成lua实现； 出色的GC优化，自定义struct，枚举在Lua和C#间传递无C# gc alloc； 编辑器下无需生成代码，开发更轻量； 引入XLua1、下载XLua工程把Assets和Tools拷贝到工程目录里面。 2、创建一个LuaManager.cs 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243using UnityEngine;using XLua;using System.IO;public class LuaManager&#123; private static LuaManager uniqueLuaManager; private static LuaEnv luaState; private LuaManager()&#123; &#125; public static LuaManager GetInstance()&#123; if (uniqueLuaManager == null) &#123; uniqueLuaManager = new LuaManager(); luaState = new LuaEnv(); &#125; return uniqueLuaManager; &#125; public static void Init()&#123; LuaManager.GetInstance(); luaState.AddLoader(CustomLoader); luaState.DoString(&quot;require &apos;Main&apos;&quot;); &#125; public static void DoString(string str)&#123; if (luaState == null) &#123; Init(); &#125; object[] rets = luaState.DoString(str); foreach(var o in rets)&#123; Debug.Log(o); &#125; &#125; static byte[] CustomLoader(ref string fileName)&#123; string luaPath = Application.dataPath + &quot;/Resources/Lua/&quot; + fileName + &quot;.lua&quot;; string strLuaContent = File.ReadAllText(luaPath); byte[] block = null; block = System.Text.Encoding.UTF8.GetBytes(strLuaContent); return block; &#125; public static void Destory()&#123; luaState.Dispose(); &#125;&#125; 调用LuaManager.Init()初始化。这个初始化可以放到刚进入游戏的时候初始化的时候。”Assets/Resources/“下创建Lua文件夹，里面新建Main.lua这个为Lua启动的第一个文件。后续Lua相关的代码可以从这里开始。这之后Lua就可以正常使用了。在其他地方也可以使用LuaManager.DoString()来运行一段Lua代码。 3、由于我们游戏内是需要使用热更CS功能。在上面之前CS已经可以运行一段Lua代码。所以采用的方案是把需要热更的代码放到CDN上。每次进入游戏的时候去CDN拉取热更的Lua代码，通过Lua代码来HotFix我们的CS代码。 Lua Hotfix Cs1、在XLua Github上，作者已经写了关于如何引入Hotfix(热补丁操作指南)。大体照着这个步骤来即可。这里需要特别注意的一个地方是，在有任何修改CS代码导致重新编译会使得之前Lua里面的xlua.hotfix失效。所以，每次有修改的时候都需要重新generate Code和hotfix inject in Editor。建议把这两个步骤放到每次出包的时候主动调用这两个，重新注入一下代码。 2、关于热更新文档里面说的标识要热更新的类型有两种方式，建议大家用第二种。第一种的话需要对要热更新的类都做[Hotfix]标签。在开发阶段我们并不知道哪些类会出现bug。所以采用第二种之后不需要对类做Hotfix标签了。第二种需要在Assets/Editor文件夹下创建HotfixCfg.cs（注意，一定要在Editor目录下）。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445 using System;using System.Collections;using System.Collections.Generic;using System.IO;using System.Reflection;using System.Text;using UnityEngine;using XLua;public static class HotfixCfg&#123; [Hotfix] public static List&lt;Type&gt; by_property &#123; get &#123; var allTypes = Assembly.Load(&quot;Assembly-CSharp&quot;).GetTypes(); var nameSpace = new List&lt;string&gt;(); foreach (var t in allTypes) &#123; if (t.Namespace != null &amp;&amp; (t.Namespace.StartsWith(&quot;这里填你的命名空间&quot;, StringComparison.CurrentCulture))) &#123; if (!nameSpace.Contains(t.Namespace)) &#123; nameSpace.Add(t.Namespace); &#125; &#125; &#125; var retList = new List&lt;Type&gt;(); var sb = new StringBuilder(); foreach (var t in allTypes) &#123; if (nameSpace.Contains(t.Namespace)) &#123; retList.Add(t); sb.AppendLine(t.FullName); &#125; &#125; File.WriteAllText(Path.Combine(Application.dataPath, &quot;../HotTypes.txt&quot;), sb.ToString()); return retList; &#125; &#125;&#125; 3、最后，每次热更之前可以把代码先放到Main.Lua测试其正确性，测试无误之后放到CDN上的Hotfix.lua里面。进游戏的时候加载Hotfix.lua里面的内容，调用LuaManager.DoString()运行这段热更代码即可。 这里只用到了Lua热更Cs代码。个人还是比较建议项目前期的时候规划这些。用了几年的CS+Lua的方式开发项目，个人认为用Lua来写界面逻辑比较适合游戏这种版本迭代快的项目。至于性能方面不管是XLua、Slua和Tolua都已经优化的不错了，而且现在手机的性能一直攀升。这方面其实问题不是特别大，有些特别耗性能的可以放到CS那边做，这些部分也不会经常改动。其他UI相关的还是用Lua比较好，而且可以小版本迭代，不需要更新整包。]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android-Studio-导入项目在-Building-gradle-project-info-一直卡住]]></title>
    <url>%2F2019%2F04%2F10%2FAndroid-Studio-%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%9C%A8-Building-gradle-project-info-%E4%B8%80%E7%9B%B4%E5%8D%A1%E4%BD%8F-1%2F</url>
    <content type="text"><![CDATA[Android Studio导入项目的时候一直卡在Building gradle project info这一步，主要原因还是因为被墙的结果。Gradle官网虽然可以正常访问，但是下载还是一直龟速。 （自己的已经解决，借用网上的图） 解决方案如下： 查看自己这个目录“C:\Users\用户名.gradle\wrapper\dists\gradle-x.xx-all\xxxxxxxxxxxxxxx”, 这里可以看到你的版本号。这个文件夹下面的gradleXXX的大小为0说明没下载完。可以去gradle官网下载对应版本。官网地址自行百度。 下载完成之后吧对应的gradlexxx.zip放到改目录下。 重启gradle，打开一个已有的项目或者新建一个项目就可以解决了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IOS自动增加build和Version]]></title>
    <url>%2F2019%2F04%2F09%2FIOS%E8%87%AA%E5%8A%A8%E5%A2%9E%E5%8A%A0build%E5%92%8CVersion%2F</url>
    <content type="text"><![CDATA[在IOS提审过程中，要求需要build号版本比现在有的版本号要大。每次release的时候需要去增加Build号，有时候难免忘记。所以添加一个打包脚本，每次release的时候自动build号加1。version为1.1.build号。 添加脚本方式为选中项目-》target-》Build Phases-》+RunScript。将下面脚本拷贝放到里面去。 1234567891011121314151617181920if [ $CONFIGURATION == Release ]; thenecho "Bumping build number..."plist=$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;buildnum=$(/usr/libexec/PlistBuddy -c "Print CFBundleVersion" "$&#123;plist&#125;")if [[ "$&#123;buildnum&#125;" == "" ]]; thenecho "No build number in $plist"exit 2fibuildnum=`echo $buildnum +1|bc`/usr/libexec/Plistbuddy -c "Set CFBundleVersion $buildnum" "$&#123;plist&#125;"/usr/libexec/Plistbuddy -c "Set CFBundleShortVersionString 1.1.$buildnum" "$&#123;plist&#125;"echo "Bumped build number to $buildnum"elseecho $CONFIGURATION " build - Not bumping build number."fi]]></content>
      <categories>
        <category>IOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unity图片优化-Dither算法（RGBA16优化）]]></title>
    <url>%2F2019%2F04%2F01%2FUnity%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96-Dither%E7%AE%97%E6%B3%95%EF%BC%88RGBA16%E4%BC%98%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在unity开发过程中，游戏图片占用了很大一部分的手机内存。所以在游戏开发中，对图片的优化也至关重要。 在Unity中常用的的图片格式有RGBA32，RGBA16，ETC，PVRTC等。这里我们主要讨论带透明通道的RGBA32和RGBA16这两种格式的图片在Unity占用的内存空间已经优化方案。 我们知道，RGBA32是R,G,B,A四个通道每个通道用8位来表示，RGBA16则是用4位。所以RGBA32能够带来更好的显示效果。同时也会带来更大的内存消耗。下面给两张RGBA16和RGBA32的对比图。 RGBA32 RGBA16 从上面两个图可以看得出，RGBA32能够带来更好的显示效果。而RGBA16在有些地方的色阶太明显，导致显示效果不尽人意。由此keijiro(Github地址)写了一个dither算法来消除这种色阶，以达到高于RGBA16低于RGBA32的显示效果。 下图为Dither优化之后的RGBA16 通过对比能明显看出优化后的RGBA16能够消除色阶，如果不是放大特意看，和RGBA32几乎差别不同。通过这种方式将内存降低一半确认带来更好的效果。 万事总会存在利弊，这个算法在消除了色阶的同事，带来的是更多的噪点。所以这个方法不适用于图片需要放大来显示的。总体来说，该方案在一定程度上还是能够带来很好的效果。最后把算法的核心代码贴出来 。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class TextureImportSetting : AssetPostprocessor &#123; string[] assetTexturePath = new string[]&#123;&quot;Assets/Resources/TextureVN/&quot;&#125;; //放置需要优化的路径 void OnPreprocessTexture()&#123; foreach (var str in assetTexturePath) &#123; if (this.assetPath.StartsWith(str) ) &#123; TextureImporter textureImporter = this.assetImporter as TextureImporter; textureImporter.textureType = TextureImporterType.Advanced; textureImporter.npotScale = TextureImporterNPOTScale.ToNearest; textureImporter.mipmapEnabled = false; textureImporter.isReadable = false; if ( textureImporter.DoesSourceTextureHaveAlpha()) &#123; textureImporter.textureFormat = TextureImporterFormat.RGBA32; &#125; &#125; &#125; &#125; public static void OnPostprocessRGB16 (Texture2D texture) &#123; var texw = texture.width; var texh = texture.height; var pixels = texture.GetPixels (); var offs = 0; var k1Per15 = 1.0f / 15.0f; var k1Per16 = 1.0f / 16.0f; var k3Per16 = 3.0f / 16.0f; var k5Per16 = 5.0f / 16.0f; var k7Per16 = 7.0f / 16.0f; for (var y = 0; y &lt; texh; y++) &#123; for (var x = 0; x &lt; texw; x++) &#123; float a = pixels [offs].a; float r = pixels [offs].r; float g = pixels [offs].g; float b = pixels [offs].b; var a2 = Mathf.Clamp01 (Mathf.Floor (a * 16) * k1Per15); var r2 = Mathf.Clamp01 (Mathf.Floor (r * 16) * k1Per15); var g2 = Mathf.Clamp01 (Mathf.Floor (g * 16) * k1Per15); var b2 = Mathf.Clamp01 (Mathf.Floor (b * 16) * k1Per15); var ae = a - a2; var re = r - r2; var ge = g - g2; var be = b - b2; pixels [offs].a = a2; pixels [offs].r = r2; pixels [offs].g = g2; pixels [offs].b = b2; var n1 = offs + 1; var n2 = offs + texw - 1; var n3 = offs + texw; var n4 = offs + texw + 1; if (x &lt; texw - 1) &#123; pixels [n1].a += ae * k7Per16; pixels [n1].r += re * k7Per16; pixels [n1].g += ge * k7Per16; pixels [n1].b += be * k7Per16; &#125; if (y &lt; texh - 1) &#123; pixels [n3].a += ae * k5Per16; pixels [n3].r += re * k5Per16; pixels [n3].g += ge * k5Per16; pixels [n3].b += be * k5Per16; if (x &gt; 0) &#123; pixels [n2].a += ae * k3Per16; pixels [n2].r += re * k3Per16; pixels [n2].g += ge * k3Per16; pixels [n2].b += be * k3Per16; &#125; if (x &lt; texw - 1) &#123; pixels [n4].a += ae * k1Per16; pixels [n4].r += re * k1Per16; pixels [n4].g += ge * k1Per16; pixels [n4].b += be * k1Per16; &#125; &#125; offs++; &#125; &#125; texture.SetPixels (pixels); EditorUtility.CompressTexture (texture, TextureFormat.RGBA4444, TextureCompressionQuality.Best); &#125; void OnPostprocessTexture(Texture2D texture)&#123; foreach (var str in assetTexturePath) &#123; if (this.assetPath.StartsWith(str) ) &#123; TextureImporter textureImporter = this.assetImporter as TextureImporter; if ( textureImporter.DoesSourceTextureHaveAlpha()) &#123; OnPostprocessRGB16(texture); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Dither</tag>
        <tag>RGBA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGUI渲染框架]]></title>
    <url>%2F2019%2F03%2F27%2FNGUI%E6%B8%B2%E6%9F%93%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[本文基于NGUI3.9.6，目前我们游戏用的NGUI版本。主要介绍一下NGUI渲染框架，基于本人阅读NGUI源码及其相关资料得出，如有误欢迎指正。 1、渲染基础组件 UIGeometry是用于保存UIWidget需要用的几何数据，里面主要有verts、uvs、cols UIWidget是NGUI基础组件（UILabel、UITexture和UISprite）的基类。主要包含了组件的一些基本信息（宽高、锚点和深度等）。 UIDrawCall 用于负责绘制的类，负责把UIWidget和UIGeometry里面的数据绘制出来 UIPanel 用来管理多个UIWidget、UIDrawcall的渲染、裁剪和更新等。 2、各个组件之间的关系 点击此处可查看大图 3、渲染流程这里先借用网上一张渲染流程图。借用地址链接：https://www.cnblogs.com/Persona/p/4149086.html UIGeometryUIGeometry内提供了verts（顶点）、uvs（UV坐标）、cols（颜色）和相对于panel的mRtpVerts（顶点）、mRtpNormal（法线）、mRtpTan（切线）的数据变量。对外提供了三个方法Clear(清理数据)、ApplyTransform、WriteToBuffers（写缓存）。主要方法：123456789101112131415161718 //用来计算把widget数据通过矩阵转化到panel数据public void ApplyTransform (Matrix4x4 widgetToPanel, bool generateNormals = true)&#123; if (verts.size &gt; 0) &#123; mRtpVerts.Clear(); for (int i = 0, imax = verts.size; i &lt; imax; ++i) mRtpVerts.Add(widgetToPanel.MultiplyPoint3x4(verts[i])); // Calculate the widget&apos;s normal and tangent if (generateNormals) &#123; mRtpNormal = widgetToPanel.MultiplyVector(Vector3.back).normalized; Vector3 tangent = widgetToPanel.MultiplyVector(Vector3.right).normalized; mRtpTan = new Vector4(tangent.x, tangent.y, tangent.z, -1f); &#125; &#125; else mRtpVerts.Clear();&#125; UIWidgetUIWidget作为NGUI基础组件提供一些基本属性操作。这里主要还是讨论他和UIGeometry和UIPanel之间的关系。 UIWidget中定了两个变量。Panel用来管理widget，geometry是widget的数据。12345678/// &lt;summary&gt;/// Panel that&apos;s managing this widget./// &lt;/summary&gt;[System.NonSerialized] public UIPanel panel;/// &lt;summary&gt;/// Widget&apos;s generated geometry./// &lt;/summary&gt;[System.NonSerialized] public UIGeometry geometry = new UIGeometry(); geometry相当于widget在整个渲染过程中的数据容器。实例化geometry的时候，通过UpdateGeometry方法来填充计算Geometry里面的数据。通过调用OnFill虚方法，最后在UILabel、UITexture、UISprite里面来填充具体对应的数据。12345678910111213141516171819public bool UpdateGeometry (int frame) &#123; //省略部分代码 if (mChanged) &#123; mChanged = false; if (mIsVisibleByAlpha &amp;&amp; finalAlpha &gt; 0.001f &amp;&amp; shader != null) &#123; bool hadVertices = geometry.hasVertices; if (fillGeometry) &#123; geometry.Clear(); OnFill(geometry.verts, geometry.uvs, geometry.cols); &#125; //省略部分代码 &#125; //省略部分代码 &#125; //省略部分代码 panel和widget的关系是一个引用的关系。widget保留了对其管理的panel的引用。是start的时候会去创建panel的引用。123456789101112131415161718/// &lt;summary&gt;/// Ensure we have a panel referencing this widget./// &lt;/summary&gt;public UIPanel CreatePanel ()&#123; if (mStarted &amp;&amp; panel == null &amp;&amp; enabled &amp;&amp; NGUITools.GetActive(gameObject)) &#123; panel = UIPanel.Find(cachedTransform, true, cachedGameObject.layer); if (panel != null) &#123; mParentFound = false; panel.AddWidget(this); CheckLayer(); Invalidate(true); &#125; &#125; return panel;&#125; UIDrawCallUIDrawCall和UIWidget的关系相当于有一堆UIWidget的数据需要被绘制，通过UIDrawCall组装起来生成Material用来渲染。UIDrawCall的Material的创建和更新在UpdateGeometry中。这个方法只有在UIPanel的FillAllDrawCalls和FillDrawCall中调用。每个Drawcall对应一个mesh，如果该DrawCall里面的包含的UIWidget有变动。那么就会调用UpdateGeometry更新数据才能重新更新效果。所以在开发过程中，应该避免UIWidget的变动，比如SetActive等。 UIDrawCall重要函数UpdateGeometry12345678910111213141516171819202122232425262728293031323334/// Set the draw call&apos;s geometry.public void UpdateGeometry (int widgetCount)&#123; //省略部分代码 if (verts.size &lt; 65000) &#123; //省略部分代码 // Create the mesh 创建mesh if (mMesh == null) &#123; mMesh = new Mesh(); mMesh.hideFlags = HideFlags.DontSave; mMesh.name = (mMaterial != null) ? &quot;[NGUI] &quot; + mMaterial.name : &quot;[NGUI] Mesh&quot;; mMesh.MarkDynamic(); setIndices = true; &#125; //省略部分代码 //填充绘制需要的数据 mMesh.vertices = verts.buffer; mMesh.uv = uvs.buffer; mMesh.colors32 = cols.buffer; if (norms != null) mMesh.normals = norms.buffer; if (tans != null) mMesh.tangents = tans.buffer; if (setIndices) &#123; mIndices = GenerateCachedIndexBuffer(count, indexCount); mMesh.triangles = mIndices; &#125; //省略部分代码 //更新材质 UpdateMaterials(); &#125;&#125; UIPanelUIPanel在NGUI中充当了一个管理者的角色。管理这UIDrawCall和UIWidget的渲染、裁剪和更新时机。UIPanel中主要的函数LateUpdate、FillAllDrawCalls和FillDrawCall。在Unity的Profile中经常能看到UIPanel.LateUpdate这个函数的CPU和GC都是占用很高的。 LateUpdateLateUpdate中更新了所有panel和drawcall。在LateUpdate中会遍历所有Panel,调用Panel中的UpdateDrawcall方法。更新所有DrawCall。LateUpdate中确保了每帧执行一次。12345678910111213141516171819202122232425262728293031323334353637383940void LateUpdate () &#123; //这里确保每帧执行一次，这个对CPU和GPU消耗很大，需要控制执行次数 if (mUpdateFrame != Time.frameCount) &#123; mUpdateFrame = Time.frameCount; // Update each panel in order for (int i = 0, imax = list.Count; i &lt; imax; ++i) list[i].UpdateSelf(); int rq = 3000; // Update all draw calls, making them draw in the right order for (int i = 0, imax = list.Count; i &lt; imax; ++i) &#123; UIPanel p = list[i]; if (p.renderQueue == RenderQueue.Automatic) &#123; p.startingRenderQueue = rq; p.UpdateDrawCalls(); //这里默认在Panel的RenderQueue之间拉开3个差值 rq += p.drawCalls.Count * 3; &#125; else if (p.renderQueue == RenderQueue.StartAt) &#123; p.UpdateDrawCalls(); if (p.drawCalls.Count != 0) rq = Mathf.Max(rq, p.startingRenderQueue + p.drawCalls.Count); &#125; else // Explicit &#123; p.UpdateDrawCalls(); if (p.drawCalls.Count != 0) rq = Mathf.Max(rq, p.startingRenderQueue + 1); &#125; &#125; &#125; &#125; 在阅读LateUpdate主要关注调用的UpdateSelf和UpdateDrawCalls方法。在UpdateSelf中主要更新了Transform、Layer、Widgets和根据需求重建Drawcall。UpdateDrawCalls更新裁剪区域和drawcall层级等信息。 FillAllDrawCalls和FillDrawCallFillAllDrawCalls是处理所有Widget和重建所有drawcall。FillDrawCalls针对某一个特殊的Drawcall更新Geometry。这里主要介绍FillAllDrawCalls。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/// &lt;summary&gt; /// Fill the geometry fully, processing all widgets and re-creating all draw calls. /// &lt;/summary&gt; void FillAllDrawCalls () &#123; //清理所有Drawcall for (int i = 0; i &lt; drawCalls.Count; ++i) UIDrawCall.Destroy(drawCalls[i]); drawCalls.Clear(); //省略部分代码 //重建Widget if (mSortWidgets) SortWidgets(); for (int i = 0; i &lt; widgets.Count; ++i) &#123; UIWidget w = widgets[i]; if (w.isVisible &amp;&amp; w.hasVertices) &#123; Material mt = w.material; Texture tx = w.mainTexture; Shader sd = w.shader; //如果当前用的材质、纹理和shader和上一个widget的不同的话增加一个Drawcall if (mat != mt || tex != tx || sdr != sd) &#123; if (dc != null &amp;&amp; dc.verts.size != 0) &#123; drawCalls.Add(dc); dc.UpdateGeometry(count); dc.onRender = mOnRender; mOnRender = null; count = 0; dc = null; &#125; mat = mt; tex = tx; sdr = sd; &#125; //drawcall为空的话，新建一个drawcall if (mat != null || sdr != null || tex != null) &#123; if (dc == null) &#123; dc = UIDrawCall.Create(this, mat, tex, sdr); dc.depthStart = w.depth; dc.depthEnd = dc.depthStart; dc.panel = this; &#125; else &#123; int rd = w.depth; if (rd &lt; dc.depthStart) dc.depthStart = rd; if (rd &gt; dc.depthEnd) dc.depthEnd = rd; &#125; w.drawCall = dc; // 写入缓存 ++count; if (generateNormals) w.WriteToBuffers(dc.verts, dc.uvs, dc.cols, dc.norms, dc.tans); else w.WriteToBuffers(dc.verts, dc.uvs, dc.cols, null, null); if (w.mOnRender != null) &#123; if (mOnRender == null) mOnRender = w.mOnRender; else mOnRender += w.mOnRender; &#125; &#125; &#125; else w.drawCall = null; &#125; if (dc != null &amp;&amp; dc.verts.size != 0) &#123; drawCalls.Add(dc); dc.UpdateGeometry(count); dc.onRender = mOnRender; mOnRender = null; &#125; &#125; FillAllDrawCalls中住的流程如下： graph TD A[清理所有DrawCall...] --> B[对Widget重新排序...] B --> C[重新更新Geomtry...] C --> D[写缓存...] 上图可以看到，在重建DrawCall的时候会重新对Widget排序，还会重新更新计算Geometry。所以这个调用是很耗时的。而FillAllDrawCalls在UIPanel中的UpdateSelf里面当mRebuild为true的时候才会重建所有Drawcall。而mRebuild的在UIPanel中在OnInit、OnEnable、RemoveWidget、Refresh中会调用。所以在我们制作UI界面的时候应该尽量避免触发这几个函数以免对Drawcall重建。造成大的消耗。 所以通过对上面的分析可以看得出，影响Drawcall的因素主要有下面几个。在实际开发中可以规划好widget，针对下面的因素来优化drawcall。 不同panel中的Widget无法合并drawcall 同一个panel中会根据panel下的widget中的depth排序，连续的widget使用的相同材质相同纹理以及shader的widget可以合并drawcall widget的add、remove和refresh都会影响drawcall重建。]]></content>
      <categories>
        <category>NGUI</category>
      </categories>
      <tags>
        <tag>NGUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles 代理跳转]]></title>
    <url>%2F2019%2F03%2F21%2FIOSCharles%E4%BB%A3%E7%90%86%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[代理目的通过代理跳转，把游戏的版本文件跳转到测试的目录下，连接test测试相关游戏功能。 步骤1、安装Charles （自行安装，不做介绍，window，mac都可以）2、确保手机和Charles 在同一个局域网3、查看Charles安装机器ip。比如为192.168.0.1384、设置手机wifi代理。代理地址192.168.0.138 端口号：88885、选择Map Remote 6、添加跳转。即可。]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next添加Valine评论系统]]></title>
    <url>%2F2019%2F03%2F21%2FNext%E6%B7%BB%E5%8A%A0Valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[介绍Valine - 一款快速、简洁且高效的无后端评论系统。(摘自Valine)1、注册Leancloud评论系统基于Leancloud（Leancloud官网，点我注册） 注册完成之后创建一个应用，名字任意。进入应用-设置应用key 2、打开next的_config.yml12345678910valine: enable: true app_id: app_key: notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ヾﾉ≧∀≦)o 来呀！快活呀！~ avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 注意：不同版本字段有所不同。可以在配置文件里面搜valine。 参考Valine官方文档]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D动态替换Lightmap]]></title>
    <url>%2F2019%2F03%2F20%2FUnity3D%E5%8A%A8%E6%80%81%E6%9B%BF%E6%8D%A2Lightmap%2F</url>
    <content type="text"><![CDATA[写在前面最近项目上有个需求，在场景里面需要做一个动态替换lightmap。主要需求是针对场景实现白天和夜晚的灯光效果。 在场景没有变化的时候，我们可以直接替换场景的lightmap即可。 1234567891011public void SetLightMap(Texture2D lightmapTex)&#123; if (lightmapTex == null) &#123; return; &#125; LightmapData[] lightmapData = LightmapSettings.lightmaps; LightmapData lmd = new LightmapData(); lmd.lightmapFar = lightmapTex; lightmapData[0] = lmd; LightmapSettings.lightmaps = lightmapData;&#125;]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Lightmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world!]]></title>
    <url>%2F2019%2F03%2F19%2Fhello%20world%2F</url>
    <content type="text"><![CDATA[程序员的第一个hello world！]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
</search>
